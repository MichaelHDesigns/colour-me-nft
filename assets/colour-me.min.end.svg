<g class="tool-group"><rect x="575" y="20" width="30" height="30" class="tool-bg active"/><text x="590" y="40" text-anchor="middle" class="tool-button">üñåÔ∏è</text></g><g class="tool-group"><rect x="615" y="20" width="30" height="30" class="tool-bg"/><text x="630" y="40" text-anchor="middle" class="tool-button">üßΩ</text></g><g class="tool-group"><rect x="655" y="20" width="30" height="30" class="tool-bg"/><text x="670" y="40" text-anchor="middle" class="tool-button">ü™£</text></g><g class="action-group"><rect x="800" y="20" width="40" height="30" class="action-bg clear"/><text x="820" y="40" text-anchor="middle" class="button-text">üí£</text><text x="820" y="65" text-anchor="middle" class="toolbar-text">Clear</text></g><g class="action-group"><rect x="860" y="20" width="40" height="30" class="action-bg save"/><text x="880" y="40" text-anchor="middle" class="button-text">üíæ</text><text x="880" y="65" text-anchor="middle" class="toolbar-text">Save</text></g><g class="action-group"><rect x="920" y="20" width="40" height="30" class="action-bg export"/><text x="940" y="40" text-anchor="middle" class="button-text">üìÅ</text><text x="940" y="65" text-anchor="middle" class="toolbar-text">Export</text></g><text x="150" y="65" text-anchor="middle" class="toolbar-text">Colors</text><text x="350" y="65" text-anchor="middle" class="toolbar-text">Brush Size</text><text x="500" y="65" text-anchor="middle" class="toolbar-text">Shapes</text><text x="630" y="65" text-anchor="middle" class="toolbar-text">Tools</text><script type="text/javascript"><![CDATA[const CANVAS_X = 10;const CANVAS_Y = 90;const CANVAS_WIDTH = 980;const CANVAS_HEIGHT = 900;const drawingArea = document.getElementById('drawing-area');const canvas = document.querySelector('.canvas');const svg = document.querySelector('svg');let isDrawing = false;let currentColor = '#000000';let currentBrushSize = 8;let currentTool = 'brush';let currentShape = 'rect';let paths = [];let currentPath = null;let startPos = null;let currentShapeElement = null;let polylinePoints = [];let polylinePreview = null;const SVG_NS = 'http://www.w3.org/2000/svg';const XHTML_NS = 'http://www.w3.org/1999/xhtml';let svgRect = null;let svgWidth = 1000;let svgHeight = 1000;let displayWidth = 1000;let displayHeight = 1000;function updateCoordinateFactors() {svgRect = svg.getBoundingClientRect();svgWidth = svg.viewBox.baseVal.width;svgHeight = svg.viewBox.baseVal.height;displayWidth = svgRect.width;displayHeight = svgRect.height;}function calculatePosition(clientX, clientY) {if (!svgRect) updateCoordinateFactors();const x = clientX - svgRect.left;const y = clientY - svgRect.top;const rawX = (x * svgWidth) / displayWidth;const rawY = (y * svgHeight) / displayHeight;return {x: Math.round(rawX),y: Math.round(rawY)};}function getMousePos(evt) {return calculatePosition(evt.clientX, evt.clientY);}function getTouchPos(evt) {const touch = evt.touches[0];return calculatePosition(touch.clientX, touch.clientY);}function createSVGElement(tagName, attributes = {}) {const element = document.createElementNS(SVG_NS, tagName);Object.entries(attributes).forEach(([key, value]) => {element.setAttribute(key, value);});return element;}function setActiveElement(selector, activeElement) {document.querySelectorAll(selector).forEach(el => el.classList.remove('active'));if (activeElement) activeElement.classList.add('active');}const shapeConfigs = {rect: (pos) => ({fill: currentColor, x: pos.x, y: pos.y, width: 1, height: 1}),ellipse: (pos) => ({fill: currentColor, cx: pos.x, cy: pos.y, rx: 1, ry: 1}),line: (pos) => ({stroke: currentColor, 'stroke-width': currentBrushSize,x1: pos.x, y1: pos.y, x2: pos.x, y2: pos.y}),'polygon-3': (pos) => ({fill: currentColor,points: `${pos.x},${pos.y} ${pos.x + 1},${pos.y + 1} ${pos.x - 1},${pos.y + 1}`}),'polygon-5': (pos) => ({fill: currentColor,points: `${pos.x},${pos.y - 0.5} ${pos.x + 0.5},${pos.y - 0.3} ${pos.x + 0.3},${pos.y + 0.5} ${pos.x - 0.3},${pos.y + 0.5} ${pos.x - 0.5},${pos.y - 0.3}`}),'polygon-6': (pos) => ({fill: currentColor,points: `${pos.x},${pos.y - 0.5} ${pos.x + 0.5},${pos.y - 0.25} ${pos.x + 0.5},${pos.y + 0.25} ${pos.x},${pos.y + 0.5} ${pos.x - 0.5},${pos.y + 0.25} ${pos.x - 0.5},${pos.y - 0.25}`})};function generatePolygonPoints(centerX, centerY, width, height, sides, offset = 0) {const points = [];for (let i = 0; i < sides; i++) {const angle = (i * 2 * Math.PI) / sides - Math.PI / 2 + offset;const x = Math.round(centerX + (width / 2) * Math.cos(angle));const y = Math.round(centerY + (height / 2) * Math.sin(angle));points.push(x, y);}return points.join(',');}function isWithinCanvas(pos) {return pos.x >= CANVAS_X && pos.x <= CANVAS_X + CANVAS_WIDTH &&pos.y >= CANVAS_Y && pos.y <= CANVAS_Y + CANVAS_HEIGHT;}document.querySelectorAll('.color-btn').forEach(btn => {btn.addEventListener('click', function() {setActiveElement('.color-btn', this);currentColor = this.getAttribute('fill');});});const brushSlider = document.getElementById('brush-slider-handle');const brushSliderTrack = document.getElementById('brush-slider-track');let isDraggingSlider = false;function updateBrushSizeFromSlider(x) {const trackRect = brushSliderTrack.getBoundingClientRect();const trackLeft = trackRect.left;const trackWidth = trackRect.width;let relativeX = x - trackLeft;relativeX = Math.max(0, Math.min(relativeX, trackWidth));const brushSize = Math.round(1 + (relativeX / trackWidth) * 39);const sliderX = 305 + (relativeX / trackWidth) * 110;brushSlider.setAttribute('cx', sliderX);currentBrushSize = brushSize;const handleRadius = Math.max(4, Math.min(20, brushSize * 0.5));brushSlider.setAttribute('r', handleRadius);}function startSliderDrag(evt) {finalizeShape();isDraggingSlider = true;updateBrushSizeFromSlider(evt.clientX);}function updateSliderDrag(evt) {if (isDraggingSlider) {updateBrushSizeFromSlider(evt.clientX);}}function stopSliderDrag() {isDraggingSlider = false;}brushSlider.addEventListener('mousedown', startSliderDrag);brushSliderTrack.addEventListener('mousedown', startSliderDrag);document.addEventListener('mousemove', updateSliderDrag);document.addEventListener('mouseup', stopSliderDrag);brushSlider.addEventListener('touchstart', function(evt) {evt.preventDefault();finalizeShape();isDraggingSlider = true;updateBrushSizeFromSlider(evt.touches[0].clientX);}, {passive: false});brushSliderTrack.addEventListener('touchstart', function(evt) {evt.preventDefault();finalizeShape();isDraggingSlider = true;updateBrushSizeFromSlider(evt.touches[0].clientX);}, {passive: false});document.addEventListener('touchmove', function(evt) {if (isDraggingSlider) {evt.preventDefault();updateBrushSizeFromSlider(evt.touches[0].clientX);}});document.addEventListener('touchend', stopSliderDrag);document.querySelectorAll('.tool-group').forEach((group, index) => {group.addEventListener('click', function() {setActiveElement('.tool-bg', this.querySelector('.tool-bg'));setActiveElement('.shape-group .tool-bg', null);const tools = ['brush', 'eraser', 'bucket'];currentTool = tools[index] || 'brush';});});document.querySelectorAll('.shape-group').forEach((group) => {group.addEventListener('click', function() {setActiveElement('.shape-group .tool-bg', this.querySelector('.tool-bg'));setActiveElement('.tool-group .tool-bg', null);const shapeType = this.querySelector('.tool-bg').getAttribute('data-shape');currentTool = 'shape';currentShape = shapeType;if (currentShape === 'polyline') {polylinePoints = [];}});});function saveDrawing(storageKey = "colourMeArt") {const drawingElements = Array.from(drawingArea.children).map(element => {const stroke = element.getAttribute('stroke') ? hexToBytes3(element.getAttribute('stroke')) : null;const fill = element.getAttribute('fill') !== '#none' ? hexToBytes3(element.getAttribute('fill')) : null;const color = stroke || fill || '0x000000';const object = {shape: getElementShape(element),color: color,stroke: parseInt(element.getAttribute('stroke-width') || '0'),points: extractPoints(element)};return object;});if (drawingElements.length > 0) {localStorage.setItem(storageKey, JSON.stringify(drawingElements));} else {localStorage.removeItem(storageKey);}return drawingElements.length > 0 ? drawingElements : null;}function getElementShape(element) {const tagName = element.tagName.toLowerCase();switch (tagName) {case 'rect': return 0;case 'line': return 1;case 'ellipse': return 2;case 'polyline': return 3;case 'polygon': return 4;case 'path': return 5;default: return 5;}}function hexToBytes3(hexColor) {return hexColor ? hexColor.replace('#', '0x') : null;}function extractPoints(element) {const tagName = element.tagName.toLowerCase();const points = [];switch (tagName) {case 'rect':const x = parseInt(element.getAttribute('x'));const y = parseInt(element.getAttribute('y'));const width = parseInt(element.getAttribute('width'));const height = parseInt(element.getAttribute('height'));points.push({ x: x, y: y });points.push({ x: width, y: height });break;case 'ellipse':const cx = parseInt(element.getAttribute('cx'));const cy = parseInt(element.getAttribute('cy'));const rx = parseInt(element.getAttribute('rx'));const ry = parseInt(element.getAttribute('ry'));points.push({ x: cx, y: cy });points.push({ x: rx, y: ry });break;case 'line':points.push({x: parseInt(element.getAttribute('x1')),y: parseInt(element.getAttribute('y1'))});points.push({x: parseInt(element.getAttribute('x2')),y: parseInt(element.getAttribute('y2'))});break;case 'polyline':const polylinePoints = extractPolylinePoints(element);points.push(...polylinePoints);break;case 'polygon':const polygonPoints = extractPolygonPoints(element);points.push(...polygonPoints);break;case 'path':const pathPoints = extractPathPoints(element);points.push(...pathPoints);break;}return points;}function extractPolylinePoints(element) {const points = [];const pointsAttr = element.getAttribute('points');const coords = pointsAttr.split(/[,\s]+/);for (let i = 0; i < coords.length; i += 2) {points.push({x: parseInt(coords[i]),y: parseInt(coords[i + 1])});}return points;}function extractPolygonPoints(element) {const points = [];const pointsAttr = element.getAttribute('points');const coords = pointsAttr.split(/[,\s]+/);for (let i = 0; i < coords.length; i += 2) {points.push({x: parseInt(coords[i]),y: parseInt(coords[i + 1])});}return points;}function extractPathPoints(element) {const points = [];const d = element.getAttribute('d');const commands = d.match(/[ML][\d.-]+\s+[\d.-]+/g) || [];commands.forEach(cmd => {const parts = cmd.trim().split(/\s+/);if (parts.length >= 2) {const command = parts[0].charAt(0);const x = parseInt(parts[0].substring(1));const y = parseInt(parts[1]);points.push({x: x,y: y});}});return points;}function loadDrawing() {const savedData = localStorage.getItem('colourMeArt');const tokenData = saveDrawing('tokenArt');if (savedData) {const contractObjects = JSON.parse(savedData);drawingArea.innerHTML = '';paths = [];contractObjects.forEach(obj => {const element = createElementFromContract(obj);if (element) {drawingArea.appendChild(element);paths.push(element);}});sendMessageToParent('LOAD_DATA', { artData: contractObjects });}}function createElementFromContract(obj) {const element = document.createElementNS(SVG_NS, getElementTag(obj.shape));switch (obj.shape) {case 0:const [pos, size] = obj.points;element.setAttribute('x', pos.x);element.setAttribute('y', pos.y);element.setAttribute('width', size.x);element.setAttribute('height', size.y);element.setAttribute('fill', bytes3ToHex(obj.color));break;case 1:const [start, end] = obj.points;element.setAttribute('x1', start.x);element.setAttribute('y1', start.y);element.setAttribute('x2', end.x);element.setAttribute('y2', end.y);element.setAttribute('stroke', bytes3ToHex(obj.color));element.setAttribute('stroke-width', obj.stroke);break;case 2:const [center, radius] = obj.points;element.setAttribute('cx', center.x);element.setAttribute('cy', center.y);element.setAttribute('rx', radius.x);element.setAttribute('ry', radius.y);element.setAttribute('fill', bytes3ToHex(obj.color));break;case 3:const polylinePointsStr = obj.points.map(p => `${p.x},${p.y}`).join(' ');element.setAttribute('points', polylinePointsStr);element.setAttribute('fill', 'none');element.setAttribute('stroke', bytes3ToHex(obj.color));element.setAttribute('stroke-width', obj.stroke);break;case 4:const polygonPointsStr = obj.points.map(p => `${p.x},${p.y}`).join(' ');element.setAttribute('points', polygonPointsStr);element.setAttribute('fill', bytes3ToHex(obj.color));break;case 5:const pathData = obj.points.map((p, i) =>`${i === 0 ? 'M' : 'L'}${p.x} ${p.y}`).join('');element.setAttribute('d', pathData);element.setAttribute('fill', 'none');element.setAttribute('stroke', bytes3ToHex(obj.color));element.setAttribute('stroke-width', obj.stroke);element.setAttribute('stroke-linecap', 'round');element.setAttribute('stroke-linejoin', 'round');break;}return element;}function getElementTag(shape) {const tags = ['rect', 'line', 'ellipse', 'polyline', 'polygon', 'path'];return tags[shape] || 'path';}function bytes3ToHex(bytes3) {const cleanHex = bytes3.replace('0x', '');return '#' + cleanHex;}function exportDrawing() {const contractObjects = saveDrawing();if (!contractObjects) return;const svgElements = contractObjects.map(obj => {const element = createElementFromContract(obj);return element.outerHTML;}).join('');const svgContent = `<?xml version="1.0" encoding="UTF-8"?><svg xmlns="http://www.w3.org/2000/svg" width="${CANVAS_WIDTH}" height="${CANVAS_HEIGHT}" viewBox="0 0 ${CANVAS_WIDTH} ${CANVAS_HEIGHT}"><rect width="${CANVAS_WIDTH}" height="${CANVAS_HEIGHT}" fill="white" />${svgElements}</svg>`;const dataUrl = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgContent);const link = document.createElementNS(XHTML_NS, 'a');link.href = dataUrl;link.download = 'painting.svg';link.click();}document.querySelectorAll('.action-group').forEach((group, index) => {group.addEventListener('click', function() {const actions = [() => {drawingArea.innerHTML = '';paths = [];saveDrawing();sendMessageToParent('CLEAR_REQUEST');},() => {const tokenArtString = localStorage.getItem('tokenArt');const saveData = saveDrawing();if (saveData) {const saveArtString = JSON.stringify(saveData);if (tokenArtString !== saveArtString) {if (tokenArtString && saveArtString.startsWith(tokenArtString.slice(0, -1))) {const tokenElements = JSON.parse(tokenArtString);const appendElements = saveData.slice(tokenElements.length);sendMessageToParent('SAVE_REQUEST', { artData: appendElements, saveType: 'append' });} else {sendMessageToParent('SAVE_REQUEST', { artData: saveData, saveType: 'set' });}}}},() => exportDrawing()];if (actions[index]) actions[index]();});});function startDrawing(pos) {if (!isWithinCanvas(pos)) return;if (currentTool === 'bucket') {drawingArea.innerHTML = '';paths = [];const fillRect = createSVGElement('rect', {x: CANVAS_X, y: CANVAS_Y, width: CANVAS_WIDTH, height: CANVAS_HEIGHT, fill: currentColor});drawingArea.appendChild(fillRect);paths.push(fillRect);return;}if (currentTool === 'shape') {if (currentShape === 'polyline') {addPolylinePoint(pos);return;} else {startPos = pos;createShapeStart(pos);return;}}isDrawing = true;currentPath = createSVGElement('path', {stroke: currentTool === 'eraser' ? 'white' : currentColor,'stroke-width': currentBrushSize,fill: 'none','stroke-linecap': 'round','stroke-linejoin': 'round',d: `M${pos.x} ${pos.y} L${pos.x} ${pos.y}`});drawingArea.appendChild(currentPath);paths.push(currentPath);}function createShapeStart(pos) {isDrawing = true;const config = shapeConfigs[currentShape];if (config) {const shape = createSVGElement(currentShape === 'line' ? 'line' :currentShape.startsWith('polygon') ? 'polygon' : currentShape, config(pos));drawingArea.appendChild(shape);currentShapeElement = shape;}}function updateShape(pos) {if (!currentShapeElement || !startPos) return;switch (currentShape) {case 'rect':const rectX = Math.min(startPos.x, pos.x);const rectY = Math.min(startPos.y, pos.y);const rectWidth = Math.abs(pos.x - startPos.x);const rectHeight = Math.abs(pos.y - startPos.y);currentShapeElement.setAttribute('x', rectX);currentShapeElement.setAttribute('y', rectY);currentShapeElement.setAttribute('width', rectWidth);currentShapeElement.setAttribute('height', rectHeight);break;case 'ellipse':const ellipseCenterX = (startPos.x + pos.x) / 2;const ellipseCenterY = (startPos.y + pos.y) / 2;const radiusX = Math.abs(pos.x - startPos.x) / 2;const radiusY = Math.abs(pos.y - startPos.y) / 2;currentShapeElement.setAttribute('cx', ellipseCenterX);currentShapeElement.setAttribute('cy', ellipseCenterY);currentShapeElement.setAttribute('rx', radiusX);currentShapeElement.setAttribute('ry', radiusY);break;case 'line':currentShapeElement.setAttribute('x2', pos.x);currentShapeElement.setAttribute('y2', pos.y);break;case 'polygon-3':case 'polygon-5':case 'polygon-6':const sides = parseInt(currentShape.split('-')[1]);const centerX = (startPos.x + pos.x) / 2;const centerY = (startPos.y + pos.y) / 2;const width = Math.abs(pos.x - startPos.x);const height = Math.abs(pos.y - startPos.y);const offset = pos.y > startPos.y ? Math.PI : 0;const points = generatePolygonPoints(centerX, centerY, width, height, sides, offset);currentShapeElement.setAttribute('points', points);break;}}function addPolylinePoint(pos) {polylinePoints.push(pos.x, pos.y);if (polylinePoints.length >= 1000) {const lastX = polylinePoints[polylinePoints.length - 4];const lastY = polylinePoints[polylinePoints.length - 3];finalizeShape();polylinePoints = [lastX, lastY, pos.x, pos.y];currentShapeElement = createSVGElement('polyline', {points: polylinePoints.join(','),fill: 'none',stroke: currentColor,'stroke-width': currentBrushSize});drawingArea.appendChild(currentShapeElement);} else {if (!currentShapeElement) {currentShapeElement = createSVGElement('polyline', {points: polylinePoints.join(','),fill: 'none',stroke: currentColor,'stroke-width': currentBrushSize});drawingArea.appendChild(currentShapeElement);} else {currentShapeElement.setAttribute('points', polylinePoints.join(','));}}}function finalizeShape() {if (currentShapeElement) {paths.push(currentShapeElement);}if (polylinePreview) {polylinePreview.remove();polylinePreview = null;}if (currentShapeElement && currentShapeElement.tagName === 'polyline') {polylinePoints = [];currentShapeElement = null;}}function draw(pos) {if (!isDrawing) return;if (currentTool === 'shape' && currentShapeElement && startPos) {updateShape(pos);return;}if (!currentPath || !isWithinCanvas(pos)) return;const currentD = currentPath.getAttribute('d');const pathPoints = currentD.match(/[ML]\s*[\d.-]+\s+[\d.-]+/g) || [];const pointCount = pathPoints.length;if (pointCount >= 500) {const lastX = pathPoints[pathPoints.length - 1].split(' ')[1];const lastY = pathPoints[pathPoints.length - 1].split(' ')[2];currentPath = createSVGElement('path', {stroke: currentTool === 'eraser' ? 'white' : currentColor,'stroke-width': currentBrushSize,fill: 'none','stroke-linecap': 'round','stroke-linejoin': 'round',d: `M${lastX} ${lastY} L${pos.x} ${pos.y}`});drawingArea.appendChild(currentPath);paths.push(currentPath);} else {currentPath.setAttribute('d', currentD + `L${pos.x} ${pos.y}`);}}function stopDrawing() {if (currentTool === 'shape' && currentShapeElement && startPos) {finalizeShape();}isDrawing = false;currentPath = null;startPos = null;if (currentTool !== 'shape' || currentShape !== 'polyline') {currentShapeElement = null;}}let mouseMoveThrottle = null;canvas.addEventListener('mousedown', function(evt) {startDrawing(getMousePos(evt));});document.addEventListener('mousemove', function(evt) {if (isDrawing) {if (mouseMoveThrottle) return;mouseMoveThrottle = requestAnimationFrame(() => {draw(getMousePos(evt));mouseMoveThrottle = null;});}if (currentTool === 'shape' && currentShape === 'polyline' && polylinePoints.length > 0) {if (!polylinePreview) {polylinePreview = createSVGElement('line', {stroke: currentColor,'stroke-width': currentBrushSize,'stroke-dasharray': [currentBrushSize*2, currentBrushSize]});drawingArea.appendChild(polylinePreview);}const lastX = polylinePoints[polylinePoints.length - 2];const lastY = polylinePoints[polylinePoints.length - 1];const pos = getMousePos(evt);polylinePreview.setAttribute('x1', lastX);polylinePreview.setAttribute('y1', lastY);polylinePreview.setAttribute('x2', pos.x);polylinePreview.setAttribute('y2', pos.y);if (!isWithinCanvas(pos)) {polylinePreview.remove();polylinePreview = null;}}});document.addEventListener('mouseup', stopDrawing);canvas.addEventListener('touchstart', function(evt) {evt.preventDefault();startDrawing(getTouchPos(evt));}, { passive: false });canvas.addEventListener('touchmove', function(evt) {evt.preventDefault();draw(getTouchPos(evt));}, { passive: false });canvas.addEventListener('touchend', function(evt) {evt.preventDefault();stopDrawing();}, { passive: false });document.addEventListener('click', function(evt) {if (currentTool === 'shape' && currentShape === 'polyline' && currentShapeElement) {const canvasRect = canvas.getBoundingClientRect();const clickX = evt.clientX;const clickY = evt.clientY;if (clickX < canvasRect.left || clickX > canvasRect.right ||clickY < canvasRect.top || clickY > canvasRect.bottom) {finalizeShape();currentShapeElement = null;polylinePoints = [];}}});document.addEventListener('touchend', function(evt) {if (currentTool === 'shape' && currentShape === 'polyline' && currentShapeElement) {const canvasRect = canvas.getBoundingClientRect();const touch = evt.changedTouches[0];const touchX = touch.clientX;const touchY = touch.clientY;if (touchX < canvasRect.left || touchX > canvasRect.right ||touchY < canvasRect.top || touchY > canvasRect.bottom) {finalizeShape();currentShapeElement = null;polylinePoints = [];}}});canvas.addEventListener('contextmenu', function(evt) {evt.preventDefault();if (currentTool === 'shape' && currentShape === 'polyline' && currentShapeElement) {finalizeShape();currentShapeElement = null;polylinePoints = [];}});canvas.addEventListener('dblclick', function(evt) {evt.preventDefault();if (currentTool === 'shape' && currentShape === 'polyline' && currentShapeElement) {finalizeShape();currentShapeElement = null;polylinePoints = [];}});function sendMessageToParent(type, data = {}) {if (window.parent && window.parent !== window) {window.parent.postMessage({ type, data }, '*');}}window.addEventListener('message', function(event) {const { type, success, message } = event.data;if (type === 'SAVE_RESPONSE') {if (success) {}saveDrawing();}});window.addEventListener('load', function() {updateCoordinateFactors();loadDrawing();const initialBrushSize = currentBrushSize;const sliderX = 305 + ((initialBrushSize - 1) / 39) * 110;brushSlider.setAttribute('cx', sliderX);const initialHandleRadius = Math.max(4, Math.min(20, initialBrushSize * 0.5));brushSlider.setAttribute('r', initialHandleRadius);});]]></script></svg>
  <!-- Tool buttons -->
  <g class="tool-group">
    <rect x="650" y="20" width="30" height="30" class="tool-bg active"/>
    <text x="665" y="40" text-anchor="middle" class="tool-button">🖌️</text>
  </g>
  
  <g class="tool-group">
    <rect x="690" y="20" width="30" height="30" class="tool-bg"/>
    <text x="705" y="40" text-anchor="middle" class="tool-button">🧽</text>
  </g>
  
  <g class="tool-group">
    <rect x="730" y="20" width="30" height="30" class="tool-bg"/>
    <text x="745" y="40" text-anchor="middle" class="tool-button">🪣</text>
  </g>
  
  <!-- Action buttons -->
  <g class="action-group">
    <rect x="800" y="20" width="40" height="30" class="action-bg clear"/>
    <text x="820" y="40" text-anchor="middle" class="button-text">💣</text>
    <text x="820" y="65" text-anchor="middle" class="toolbar-text">Clear</text>
  </g>
  
  <g class="action-group">
    <rect x="860" y="20" width="40" height="30" class="action-bg save"/>
    <text x="880" y="40" text-anchor="middle" class="button-text">💾</text>
    <text x="880" y="65" text-anchor="middle" class="toolbar-text">Save</text>
  </g>
  
  <g class="action-group">
    <rect x="920" y="20" width="40" height="30" class="action-bg export"/>
    <text x="940" y="40" text-anchor="middle" class="button-text">📁</text>
    <text x="940" y="65" text-anchor="middle" class="toolbar-text">Export</text>
  </g>
  
  <!-- Labels -->
  <text x="150" y="65" text-anchor="middle" class="toolbar-text">Colors</text>
  <text x="350" y="65" text-anchor="middle" class="toolbar-text">Brush Size</text>
  <text x="500" y="65" text-anchor="middle" class="toolbar-text">Shapes</text>
  <text x="700" y="65" text-anchor="middle" class="toolbar-text">Tools</text>

  <script type="text/javascript">
    <![CDATA[
      // Canvas constants
      const CANVAS_X = 10;
      const CANVAS_Y = 90;
      const CANVAS_WIDTH = 980;
      const CANVAS_HEIGHT = 900;
      // Cached DOM elements for better performance
      const drawingArea = document.getElementById('drawing-area');
      const canvas = document.querySelector('.canvas');
      const svg = document.querySelector('svg');
      // Painting app functionality
      let isDrawing = false;
      let currentColor = '#000000';
      let currentBrushSize = 8;
      let currentTool = 'brush'; // 'brush', 'eraser', 'bucket', 'shape'
      let currentShape = 'rect'; // 'rect', 'ellipse', 'polygon', 'line', 'polyline'
      let paths = [];
      let currentPath = null;
      let startPos = null;
      let currentShapeElement = null;
      let polylinePoints = [];
      let polygonPoints = [];
      let polylinePreview = null;
      // Cached SVG namespace for better performance
      const SVG_NS = 'http://www.w3.org/2000/svg';
      const XHTML_NS = 'http://www.w3.org/1999/xhtml';
      // Cached coordinate conversion factors
      let svgRect = null;
      let svgWidth = 1000;
      let svgHeight = 1000;
      let displayWidth = 1000;
      let displayHeight = 1000;
      // Update coordinate conversion factors
      function updateCoordinateFactors() {
        svgRect = svg.getBoundingClientRect();
        svgWidth = svg.viewBox.baseVal.width;
        svgHeight = svg.viewBox.baseVal.height;
        displayWidth = svgRect.width;
        displayHeight = svgRect.height;
      }
      // Optimized position calculation function
      function calculatePosition(clientX, clientY) {
        if (!svgRect) updateCoordinateFactors();
        const x = clientX - svgRect.left;
        const y = clientY - svgRect.top;
        const rawX = (x * svgWidth) / displayWidth;
        const rawY = (y * svgHeight) / displayHeight;
        return {
          x: Math.round(rawX * 10) / 10,
          y: Math.round(rawY * 10) / 10
        };
      }
      // Unified position getter for mouse and touch
      function getMousePos(evt) {
        return calculatePosition(evt.clientX, evt.clientY);
      }
      function getTouchPos(evt) {
        const touch = evt.touches[0];
        return calculatePosition(touch.clientX, touch.clientY);
      }
      // Optimized element creation with batch attribute setting
      function createSVGElement(tagName, attributes = {}) {
        const element = document.createElementNS(SVG_NS, tagName);
        Object.entries(attributes).forEach(([key, value]) => {
          element.setAttribute(key, value);
        });
        return element;
      }
      // Optimized class manipulation
      function setActiveElement(selector, activeElement) {
        document.querySelectorAll(selector).forEach(el => el.classList.remove('active'));
        if (activeElement) activeElement.classList.add('active');
      }
      // Optimized shape creation with predefined attributes
      const shapeConfigs = {
        rect: (pos) => ({
          fill: currentColor, x: pos.x, y: pos.y, width: 1, height: 1
        }),
        ellipse: (pos) => ({
          fill: currentColor, cx: pos.x, cy: pos.y, rx: 1, ry: 1
        }),
        line: (pos) => ({
          stroke: currentColor, 'stroke-width': currentBrushSize, 
          x1: pos.x, y1: pos.y, x2: pos.x, y2: pos.y
        }),
        'polygon-3': (pos) => ({
          fill: currentColor,
          points: `${pos.x},${pos.y} ${pos.x + 1},${pos.y + 1} ${pos.x - 1},${pos.y + 1}`
        }),
        'polygon-5': (pos) => ({
          fill: currentColor,
          points: `${pos.x},${pos.y - 0.5} ${pos.x + 0.5},${pos.y - 0.3} ${pos.x + 0.3},${pos.y + 0.5} ${pos.x - 0.3},${pos.y + 0.5} ${pos.x - 0.5},${pos.y - 0.3}`
        }),
        'polygon-6': (pos) => ({
          fill: currentColor,
          points: `${pos.x},${pos.y - 0.5} ${pos.x + 0.5},${pos.y - 0.25} ${pos.x + 0.5},${pos.y + 0.25} ${pos.x},${pos.y + 0.5} ${pos.x - 0.5},${pos.y + 0.25} ${pos.x - 0.5},${pos.y - 0.25}`
        })
      };
      // Optimized polygon point generation
      function generatePolygonPoints(centerX, centerY, width, height, sides, offset = 0) {
        const points = [];
        for (let i = 0; i < sides; i++) {
          const angle = (i * 2 * Math.PI) / sides - Math.PI / 2 + offset;
          const x = Math.round((centerX + (width / 2) * Math.cos(angle)) * 100) / 100;
          const y = Math.round((centerY + (height / 2) * Math.sin(angle)) * 100) / 100;
          points.push(x, y);
        }
        return points.join(',');
      }
      // Optimized boundary checking
      function isWithinCanvas(pos) {
        return pos.x >= CANVAS_X && pos.x <= CANVAS_X + CANVAS_WIDTH && 
               pos.y >= CANVAS_Y && pos.y <= CANVAS_Y + CANVAS_HEIGHT;
      }
      // Color selection with optimized event handling
      document.querySelectorAll('.color-btn').forEach(btn => {
        btn.addEventListener('click', function() {
          if (currentTool === 'shape' && currentShape !== 'polyline') finalizeShape();
          setActiveElement('.color-btn', this);
          currentColor = this.getAttribute('fill');
        });
      });
      // Brush size selection
      document.querySelectorAll('.brush-size').forEach(btn => {
        btn.addEventListener('click', function() {
          if (currentTool === 'shape' && currentShape !== 'polyline') finalizeShape();
          setActiveElement('.brush-size', this);
          currentBrushSize = parseInt(this.getAttribute('data-size'));
        });
      });
      // Tool selection with optimized class management
      document.querySelectorAll('.tool-group').forEach((group, index) => {
        group.addEventListener('click', function() {
          if (currentTool === 'shape') finalizeShape();
          
          setActiveElement('.tool-bg', this.querySelector('.tool-bg'));
          setActiveElement('.shape-group .tool-bg', null);
          
          const tools = ['brush', 'eraser', 'bucket'];
          currentTool = tools[index] || 'brush';
        });
      });
      // Shape selection
      document.querySelectorAll('.shape-group').forEach((group) => {
        group.addEventListener('click', function() {
          if (currentTool === 'shape' && currentShape !== 'polyline') finalizeShape();
          
          setActiveElement('.tool-group .tool-bg', null);
          setActiveElement('.shape-group .tool-bg', this.querySelector('.tool-bg'));
          
          const shapeType = this.querySelector('.tool-bg').getAttribute('data-shape');
          currentTool = 'shape';
          currentShape = shapeType;
        });
      });
      // Optimized save function with reduced DOM queries
      function saveDrawing() {
        const drawingElements = Array.from(drawingArea.children).map(element => {
          const data = { elementType: element.tagName.toLowerCase() };
          Array.from(element.attributes).forEach(attr => {
            data[attr.name] = attr.value;
          });
          return data;
        });
        localStorage.setItem('paintAppData', JSON.stringify(drawingElements));
      }
      // Optimized load function with element creation mapping
      const elementCreators = {
        path: () => document.createElementNS(SVG_NS, 'path'),
        rect: () => document.createElementNS(SVG_NS, 'rect'),
        ellipse: () => document.createElementNS(SVG_NS, 'ellipse'),
        polygon: () => document.createElementNS(SVG_NS, 'polygon'),
        line: () => document.createElementNS(SVG_NS, 'line'),
        polyline: () => document.createElementNS(SVG_NS, 'polyline')
      };
      function loadDrawing() {
        const savedData = localStorage.getItem('paintAppData');
        if (savedData) {
          const drawingElements = JSON.parse(savedData);
          drawingArea.innerHTML = '';
          paths = [];
          drawingElements.forEach(data => {
            const creator = elementCreators[data.elementType];
            if (creator) {
              const element = creator();
              Object.entries(data).forEach(([key, value]) => {
                if (key !== 'elementType') {
                  element.setAttribute(key, value);
                }
              });
              drawingArea.appendChild(element);
              paths.push(element);
            }
          });
        }
      }
      // Optimized export function with reduced string operations
      function exportDrawing() {
        const clonedElements = Array.from(drawingArea.children).map(element => {
          const clone = element.cloneNode(true);
          if (clone.tagName === 'path') {
            const d = clone.getAttribute('d');
            const adjustedD = d.replace(/[ML]\s*([\d.]+)\s+([\d.]+)/g, (match, x, y) => {
              return match.charAt(0) + ' ' + (parseFloat(x) - CANVAS_X) + ' ' + (parseFloat(y) - CANVAS_Y);
            });
            clone.setAttribute('d', adjustedD);
          } else if (clone.tagName === 'rect') {
            const x = parseFloat(clone.getAttribute('x')) - CANVAS_X;
            const y = parseFloat(clone.getAttribute('y')) - CANVAS_Y;
            clone.setAttribute('x', x);
            clone.setAttribute('y', y);
          }
          return clone.outerHTML;
        }).join('');
        const svgContent = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="${CANVAS_WIDTH}" height="${CANVAS_HEIGHT}" viewBox="0 0 ${CANVAS_WIDTH} ${CANVAS_HEIGHT}">
  <rect width="${CANVAS_WIDTH}" height="${CANVAS_HEIGHT}" fill="white" />
  ${clonedElements}
</svg>`;
        const dataUrl = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(svgContent);
        const link = document.createElementNS(XHTML_NS, 'a');
        link.href = dataUrl;
        link.download = 'painting.svg';
        link.click();
      }
      // Action buttons with optimized event handling
      document.querySelectorAll('.action-group').forEach((group, index) => {
        group.addEventListener('click', function() {
          const actions = [
            () => { // Clear
              drawingArea.innerHTML = '';
              paths = [];
              sendMessageToParent('CLEAR_REQUEST');
            },
            () => { // Save
              sendMessageToParent('SAVE_REQUEST');
              saveDrawing();
            },
            () => exportDrawing() // Export
          ];
          if (actions[index]) actions[index]();
        });
      });
      // Optimized drawing functions
      function startDrawing(pos) {
        if (!isWithinCanvas(pos)) return;
        if (currentTool === 'bucket') {
          drawingArea.innerHTML = '';
          paths = [];
          const fillRect = createSVGElement('rect', {
            x: CANVAS_X, y: CANVAS_Y, width: CANVAS_WIDTH, height: CANVAS_HEIGHT, fill: currentColor
          });
          drawingArea.appendChild(fillRect);
          paths.push(fillRect);
          return;
        }
        if (currentTool === 'shape') {
          if (currentShape === 'polyline') {
            addPolylinePoint(pos);
            return;
          } else {
            startPos = pos;
            createShapeStart(pos);
            return;
          }
        }
        isDrawing = true;
        currentPath = createSVGElement('path', {
          stroke: currentTool === 'eraser' ? 'white' : currentColor,
          'stroke-width': currentBrushSize,
          fill: 'none',
          'stroke-linecap': 'round',
          'stroke-linejoin': 'round',
          d: `M ${pos.x} ${pos.y} L ${pos.x} ${pos.y}`
        });
        drawingArea.appendChild(currentPath);
        paths.push(currentPath);
      }
      function createShapeStart(pos) {
        isDrawing = true;
        const config = shapeConfigs[currentShape];
        if (config) {
          const shape = createSVGElement(currentShape === 'line' ? 'line' : 
            currentShape.startsWith('polygon') ? 'polygon' : currentShape, config(pos));
          drawingArea.appendChild(shape);
          currentShapeElement = shape;
        }
      }
      function updateShape(pos) {
        if (!currentShapeElement || !startPos) return;
        switch (currentShape) {
          case 'rect':
            const rectX = Math.min(startPos.x, pos.x);
            const rectY = Math.min(startPos.y, pos.y);
            const rectWidth = Math.abs(pos.x - startPos.x);
            const rectHeight = Math.abs(pos.y - startPos.y);
            currentShapeElement.setAttribute('x', rectX);
            currentShapeElement.setAttribute('y', rectY);
            currentShapeElement.setAttribute('width', rectWidth);
            currentShapeElement.setAttribute('height', rectHeight);
            break;
          case 'ellipse':
            const ellipseCenterX = (startPos.x + pos.x) / 2;
            const ellipseCenterY = (startPos.y + pos.y) / 2;
            const radiusX = Math.abs(pos.x - startPos.x) / 2;
            const radiusY = Math.abs(pos.y - startPos.y) / 2;
            currentShapeElement.setAttribute('cx', ellipseCenterX);
            currentShapeElement.setAttribute('cy', ellipseCenterY);
            currentShapeElement.setAttribute('rx', radiusX);
            currentShapeElement.setAttribute('ry', radiusY);
            break;
          case 'line':
            currentShapeElement.setAttribute('x2', pos.x);
            currentShapeElement.setAttribute('y2', pos.y);
            break;
          case 'polygon-3':
          case 'polygon-5':
          case 'polygon-6':
            const sides = parseInt(currentShape.split('-')[1]);
            const polyCenterX = (startPos.x + pos.x) / 2;
            const polyCenterY = (startPos.y + pos.y) / 2;
            const width = Math.abs(pos.x - startPos.x);
            const height = Math.abs(pos.y - startPos.y);
            const offset = pos.y > startPos.y ? Math.PI : 0;
            const points = generatePolygonPoints(polyCenterX, polyCenterY, width, height, sides, offset);
            currentShapeElement.setAttribute('points', points);
            break;
        }
      }
      function addPolylinePoint(pos) {
        polylinePoints.push(pos.x, pos.y);
        if (!currentShapeElement) {
          currentShapeElement = createSVGElement('polyline', {
            points: polylinePoints.join(','),
            fill: 'none',
            stroke: currentColor,
            'stroke-width': currentBrushSize
          });
          drawingArea.appendChild(currentShapeElement);
        } else {
          currentShapeElement.setAttribute('points', polylinePoints.join(','));
        }
      }
      function finalizeShape() {
        if (currentShapeElement) {
          paths.push(currentShapeElement);
        }
        if (polylinePreview) {
          polylinePreview.remove();
          polylinePreview = null;
        }
        // Only reset polylinePoints if we're not in polyline mode
        if (currentTool !== 'shape' || currentShape !== 'polyline') {
          polylinePoints = [];
        }
        polygonPoints = [];
      }
      function draw(pos) {
        if (!isDrawing) return;
        if (currentTool === 'shape' && currentShapeElement && startPos) {
          updateShape(pos);
          return;
        }
        if (!currentPath || !isWithinCanvas(pos)) return;
        const currentD = currentPath.getAttribute('d');
        currentPath.setAttribute('d', currentD + ` L ${pos.x} ${pos.y}`);
      }
      function stopDrawing() {
        if (currentTool === 'shape' && currentShapeElement && startPos) {
          finalizeShape();
        }
        isDrawing = false;
        currentPath = null;
        startPos = null;
        // Don't reset currentShapeElement for polyline - we want to keep adding to it
        if (currentTool !== 'shape' || currentShape !== 'polyline') {
          currentShapeElement = null;
        }
      }
      // Optimized event handlers with throttling for mousemove
      let mouseMoveThrottle = null;
      canvas.addEventListener('mousedown', function(evt) {
        startDrawing(getMousePos(evt));
      });
      document.addEventListener('mousemove', function(evt) {
        if (isDrawing) {
          if (mouseMoveThrottle) return;
          mouseMoveThrottle = requestAnimationFrame(() => {
            draw(getMousePos(evt));
            mouseMoveThrottle = null;
          });
        }
        if (currentTool === 'shape' && currentShape === 'polyline' && polylinePoints.length > 0) {
          if (!polylinePreview) {
            polylinePreview = createSVGElement('line', {
              stroke: currentColor,
              'stroke-width': currentBrushSize,
              'stroke-dasharray': [currentBrushSize*2, currentBrushSize]
            });
            drawingArea.appendChild(polylinePreview);
          }
          const lastX = polylinePoints[polylinePoints.length - 2];
          const lastY = polylinePoints[polylinePoints.length - 1];
          const pos = getMousePos(evt);
          polylinePreview.setAttribute('x1', lastX);
          polylinePreview.setAttribute('y1', lastY);
          polylinePreview.setAttribute('x2', pos.x);
          polylinePreview.setAttribute('y2', pos.y);
          if (!isWithinCanvas(pos)) {
            polylinePreview.remove();
            polylinePreview = null;
          }
        }
      });
      document.addEventListener('mouseup', stopDrawing);
      // Touch events
      canvas.addEventListener('touchstart', function(evt) {
        evt.preventDefault();
        startDrawing(getTouchPos(evt));
      });
      canvas.addEventListener('touchmove', function(evt) {
        evt.preventDefault();
        draw(getTouchPos(evt));
      });
      canvas.addEventListener('touchend', function(evt) {
        evt.preventDefault();
        stopDrawing();
      });
      // Context menu prevention
      canvas.addEventListener('contextmenu', function(evt) {
        evt.preventDefault();
        if (currentTool === 'shape' && currentShape === 'polyline' && currentShapeElement) {
          // Finalize polyline on right-click
          finalizeShape();
          currentShapeElement = null;
          polylinePoints = [];
        }
      });
      
      // Double-click to finish polyline
      canvas.addEventListener('dblclick', function(evt) {
        evt.preventDefault();
        if (currentTool === 'shape' && currentShape === 'polyline' && currentShapeElement) {
          finalizeShape();
          currentShapeElement = null;
          polylinePoints = [];
        }
      });
      // Communication with HTML parent
      function sendMessageToParent(type, data = {}) {
        if (window.parent && window.parent !== window) {
          window.parent.postMessage({ type, data }, '*');
        }
      }
      // Message listener
      window.addEventListener('message', function(event) {
        const { type, success, message } = event.data;
        if (type === 'SAVE_RESPONSE') {
          if (success) {
            // Blockchain ready, drawing already saved in action handler
          }
          saveDrawing();
        }
      });
      // Initialize on load
      window.addEventListener('load', function() {
        updateCoordinateFactors();
        loadDrawing();
        
        // THIS CODE SHOULD BE REMOVED FOR PRODUCTION!!!
        // TEMPORARY: Assign random colors to color buttons (except first one)
        // TODO: Remove this function when no longer needed
        function assignRandomColors() {
          const colorButtons = document.querySelectorAll('.color-btn');
          const colors = ['#ff0000', '#0000ff', '#00ff00', '#ffff00', '#ff00ff'];
          
          // Generate 5 random colors
          for (let i = 1; i < colorButtons.length; i++) {
            const randomColor = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
            colorButtons[i].setAttribute('fill', randomColor);
          }
        }
        
        // TEMPORARY: Assign random shapes to shape buttons
        // TODO: Remove this function when no longer needed
        function assignRandomShapes() {
          const shapeUseElements = document.querySelectorAll('.shape-btn');
          const shapeIds = ['shape-0', 'shape-1', 'shape-2', 'shape-3']; // Basic shapes
          const polygonIds = ['polygon-3', 'polygon-5', 'polygon-6']; // Polygons
          
          // Shuffle arrays to get random selection
          const shuffledShapes = shapeIds.sort(() => Math.random() - 0.5);
          const shuffledPolygons = polygonIds.sort(() => Math.random() - 0.5);
          
          // Assign 2 random shapes and 1 random polygon
          shapeUseElements[0].setAttribute('href', '#' + shuffledShapes[0]);
          shapeUseElements[1].setAttribute('href', '#' + shuffledShapes[1]);
          shapeUseElements[2].setAttribute('href', '#' + shuffledPolygons[0]);
        }
        
        // Uncomment the lines below to enable random colors and shapes
        assignRandomColors();
        assignRandomShapes();
      });
    ]]>
  </script>
</svg>

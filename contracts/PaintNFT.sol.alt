// SPDX-License-Identifier: AGPL-3.0-only
pragma solidity ^0.8.20;

import "./interfaces/IPaintRenderer.sol";
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Base64.sol";

contract PaintNFT is ERC721, Ownable {
    using Strings for uint256;
    using Base64 for bytes;

    constructor(
        string memory name, 
        string memory symbol,
        string memory _baseURL,
        uint256 _maxSupply,
        address _paintRenderer,
        address _owner
    ) ERC721(name, symbol) Ownable(_owner) {
        baseURL = _baseURL;
        maxSupply = _maxSupply;
        paintRenderer = IPaintRenderer(_paintRenderer);
    }

    string public baseURL;
    bytes public svgStart;
    bytes public svgEnd;
    uint256 public tokenCount;
    uint256 public maxSupply;
    IPaintRenderer public paintRenderer;

    mapping(uint256 => Trait) public traits;
    mapping(uint256 => bytes) public traitSVG;
    mapping(uint256 => Object[]) public art;
    mapping(uint256 => bytes) public artSVG;

    function setSVG(bytes memory _svgStart, bytes memory _svgEnd) external onlyOwner {
        svgStart = _svgStart;
        svgEnd = _svgEnd;
    }

    function _randomTraits(uint256 tokenId) internal view returns (Trait memory) {
        uint24[] memory colors = new uint24[](5);
        colors[0] = uint24(random_(tokenId, 1, 0xfffffe));
        colors[1] = uint24(random_(colors[0], 1, 0xfffffd));
        if (colors[1] >= colors[0]) colors[1] ++;
        colors[2] = uint24(random_(colors[1], 1, 0xfffffc));
        if (colors[2] >= colors[0]) colors[2] ++;
        if (colors[2] >= colors[1]) colors[2] ++;
        colors[3] = uint24(random_(colors[2], 1, 0xfffffb));
        if (colors[3] == colors[0]) colors[3] ++;
        if (colors[3] >= colors[1]) colors[3] ++;
        if (colors[3] >= colors[2]) colors[3] ++;
        colors[4] = uint24(random_(colors[3], 1, 0xfffffa));
        if (colors[4] >= colors[0]) colors[4] ++;
        if (colors[4] >= colors[1]) colors[4] ++;
        if (colors[4] >= colors[2]) colors[4] ++;
        if (colors[4] >= colors[3]) colors[4] ++;
        uint8[] memory shapes = new uint8[](2);
        shapes[0] = uint8(random_(colors[4], 0, 3));
        shapes[1] = uint8(random_(shapes[0], 0, 2));
        if (shapes[1] >= shapes[0]) shapes[1] ++;
        uint8 polygon = uint8(random_(shapes[1], 4, 6));
        if (polygon == 4) polygon = 3;
        return Trait({
            color0: bytes3(colors[0]),
            color1: bytes3(colors[1]),
            color2: bytes3(colors[2]),
            color3: bytes3(colors[3]),
            color4: bytes3(colors[4]),
            shape0: Path(shapes[0]),
            shape1: Path(shapes[1]),
            polygon: polygon
        });
    }

    function mint(address to) external {
        tokenCount++;
        _mint(to, tokenCount);
        traits[tokenCount] = _randomTraits(tokenCount);
        traitSVG[tokenCount] = paintRenderer.renderTrait(traits[tokenCount]);
    }

    function _objectAllowed(uint256 tokenId, Object memory object) internal view {
        if (!(
            object.shape == traits[tokenId].shape0 || 
            object.shape == traits[tokenId].shape1 ||
            object.shape == Path.polygon ||
            object.shape == Path.path
        )) {
            revert InvalidShape(uint8(object.shape));
        }
        if (!(
            object.color == 0x000000 ||
            object.color == 0xffffff ||
            object.color == traits[tokenId].color0 || 
            object.color == traits[tokenId].color1 || 
            object.color == traits[tokenId].color2 || 
            object.color == traits[tokenId].color3 || 
            object.color == traits[tokenId].color4
        )) {
            revert InvalidColor(object.color);
        }
        if ((
            object.shape == Path.line || 
            object.shape == Path.polyline ||
            object.shape == Path.path) && 
            !(
                object.stroke == 8 ||
                object.stroke == 15 ||
                object.stroke == 25 ||
                object.stroke == 40
        )) {
            revert InvalidStroke(object.stroke);
        }
        // find MAX_POINTS for ethereum transaction limits
        if (
            object.shape == Path.rect || 
            object.shape == Path.ellipse || 
            object.shape == Path.line
        ) {
            if (object.points.length != 2) {
                revert InvalidPoints(object.points.length);
            }
        } else if (object.shape == Path.polygon) {
            if (object.points.length != traits[tokenId].polygon) {
                revert InvalidPolygon(object.points.length);
            }
        }
        // pass
    }

    function setArt(uint256 tokenId, Object[] memory _art) external {
        for (uint256 i = 0; i < _art.length; i++) {
            _objectAllowed(tokenId, _art[i]);
        }
        delete artSVG[tokenId];
        artSVG[tokenId] = abi.encodePacked(
            '<g id="drawing-area" clip-path="url(#canvas-clip)">',
                paintRenderer.renderObjects(_art),
            '</g>'
        );
    }

    function appendArt(uint256 tokenId, Object[] memory _object) external {
        if (artSVG[tokenId].length == 0) {
            revert OutOfBounds(_object.length, 0);
        }
        for (uint256 i = 0; i < _object.length; i++) {
            _objectAllowed(tokenId, _object[i]);
        }
        
        // Pre-compute the total size needed
        bytes memory renderedObjects = paintRenderer.renderObjects(_object);
        uint256 currentLength = artSVG[tokenId].length;
        uint256 newLength = currentLength - 4 + renderedObjects.length + 4; // Remove </g>, add rendered objects, add </g>
        
        // Create new buffer with exact size
        bytes memory newArtSVG = new bytes(newLength);
        
        // Copy existing SVG content (excluding last 4 bytes which are </g>)
        bytes memory currentSVG = artSVG[tokenId];
        assembly {
            // memcpy via identity pre-compile (address 0x04)
            let len := sub(currentLength, 4)                       // length to copy (excluding </g>)
            let src := add(currentSVG, 32)                         // source: existing SVG
            let dst := add(newArtSVG, 32)                          // destination: new buffer
            pop(staticcall(gas(), 4, src, len, dst, len))
        }
        
        // Copy rendered objects
        assembly {
            let len := mload(renderedObjects)                      // length of rendered objects
            let src := add(renderedObjects, 32)                    // source: rendered objects
            let dst := add(add(newArtSVG, 32), sub(currentLength, 4)) // destination: after existing content
            pop(staticcall(gas(), 4, src, len, dst, len))
        }
        
        // Add closing </g> at the end
        assembly {
            let dst := add(add(newArtSVG, 32), sub(newLength, 4)) // destination: last 4 bytes
            mstore8(dst, 0x3c)                                    // '<'
            mstore8(add(dst, 1), 0x2f)                            // '/'
            mstore8(add(dst, 2), 0x67)                            // 'g'
            mstore8(add(dst, 3), 0x3e)                            // '>'
        }
        
        artSVG[tokenId] = newArtSVG;
    }

    function _renderSVG(uint256 tokenId) internal view returns (bytes memory) {
        return abi.encodePacked(
            svgStart, 
            traitSVG[tokenId],
            artSVG[tokenId], 
            svgEnd
        );
    }

    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        _requireOwned(tokenId);
        return string(abi.encodePacked(
            '{"name":"', name(), ' #', tokenId.toString(), '",',
                '"description":"Color your NFT your way. Proving you can create an SVG using an SVG on the blockchain",',
                '"external_url":"', baseURL,'#', tokenId.toString(), '",',
                '"image_data":"data:image/svg+xml;base64,', _renderSVG(tokenId).encode(), '",'
                '"attributes":', paintRenderer.getAttributes(traits[tokenId]),
            '}'
        ));
    }
}
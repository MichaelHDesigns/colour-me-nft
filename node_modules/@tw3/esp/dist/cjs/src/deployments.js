"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = exports.espDeployments = void 0;
exports.getContractAddress = getContractAddress;
exports.getDeploymentInfo = getDeploymentInfo;
exports.getSupportedChainIds = getSupportedChainIds;
exports.loadContract = loadContract;
exports.addLocalhostDeployment = addLocalhostDeployment;
exports.removeLocalhostDeployment = removeLocalhostDeployment;
exports.listAllDeployments = listAllDeployments;
exports.hasLocalhostDeployment = hasLocalhostDeployment;
const DataPointRegistry__factory_1 = require("../typechain-types/factories/contracts/DataPointRegistry__factory");
const DataPointStorage__factory_1 = require("../typechain-types/factories/contracts/DataPointStorage__factory");
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
var esp_deployments_1 = require("../esp.deployments");
Object.defineProperty(exports, "espDeployments", { enumerable: true, get: function () { return esp_deployments_1.espDeployments; } });
Object.defineProperty(exports, "default", { enumerable: true, get: function () { return __importDefault(esp_deployments_1).default; } });
// Cache for modified deployments to avoid file I/O on every call
let _modifiedDeployments = null;
// Utility functions for working with deployments
function getContractAddress(chainId, contract) {
    const deployments = _getDeployments();
    return deployments.chains[chainId]?.[contract]?.contractAddress;
}
function getDeploymentInfo(chainId, contract) {
    const deployments = _getDeployments();
    return deployments.chains[chainId]?.[contract];
}
function getSupportedChainIds() {
    const deployments = _getDeployments();
    return Object.keys(deployments.chains).map(Number);
}
function loadContract(chainId, contract, provider = null) {
    const contractAddress = getContractAddress(chainId, contract);
    if (!contractAddress) {
        throw new Error(`Contract address not found for chainId: ${chainId} and contract: ${contract}`);
    }
    let contractInstance = undefined;
    if (contract === 'dps') {
        contractInstance = DataPointRegistry__factory_1.DataPointRegistry__factory.connect(contractAddress, provider);
    }
    else {
        contractInstance = DataPointStorage__factory_1.DataPointStorage__factory.connect(contractAddress, provider);
    }
    return contractInstance;
}
/**
 * Add a localhost deployment to your local package copy
 * This allows testing with your own deployed contracts without testnet tokens
 *
 * @param deploymentData - The deployment information to add
 * @param options - Configuration options
 */
function addLocalhostDeployment(deploymentData, options = {}) {
    // Only allow localhost/hardhat networks
    if (deploymentData.chainId !== 31337 && deploymentData.chainId !== 1337) {
        throw new Error(`addLocalhostDeployment only accepts localhost networks (chainId 31337 or 1337), got ${deploymentData.chainId}`);
    }
    const { overwrite = false, description } = options;
    try {
        const deploymentsPath = _getDeploymentsFilePath();
        const deployments = _getDeployments();
        // Check if deployment already exists
        if (deployments.chains[deploymentData.chainId] && !overwrite) {
            throw new Error(`Deployment for chainId ${deploymentData.chainId} already exists. Use { overwrite: true } to replace it.`);
        }
        const timestamp = new Date().toISOString();
        // Create the new deployment entry
        const newDeployment = {
            dps: {
                contractAddress: deploymentData.dps.contractAddress,
                deployerAddress: deploymentData.dps.deployerAddress,
                txHash: deploymentData.dps.txHash || 'manual-entry',
                deployedAt: timestamp,
                ...(description && { description })
            },
            dpr: {
                contractAddress: deploymentData.dpr.contractAddress,
                deployerAddress: deploymentData.dpr.deployerAddress,
                txHash: deploymentData.dpr.txHash || 'manual-entry',
                deployedAt: timestamp,
                constructors: deploymentData.dpr.constructors,
                ...(description && { description })
            }
        };
        // Add to deployments
        deployments.chains[deploymentData.chainId] = newDeployment;
        // Update the in-memory cache
        _modifiedDeployments = deployments;
        // Write to file (this modifies the user's local copy)
        _writeDeploymentsFile(deploymentsPath, deployments);
        console.log(`✅ Added localhost deployment for chainId ${deploymentData.chainId}`);
        console.log(`📍 DPS: ${deploymentData.dps.contractAddress}`);
        console.log(`📍 DPR: ${deploymentData.dpr.contractAddress}`);
    }
    catch (error) {
        console.error(`❌ Failed to add localhost deployment:`, error);
        throw error;
    }
}
/**
 * Remove a localhost deployment from your local package copy
 *
 * @param chainId - The chain ID to remove (must be localhost: 31337 or 1337)
 */
function removeLocalhostDeployment(chainId) {
    if (chainId !== 31337 && chainId !== 1337) {
        throw new Error(`removeLocalhostDeployment only accepts localhost networks (chainId 31337 or 1337), got ${chainId}`);
    }
    try {
        const deploymentsPath = _getDeploymentsFilePath();
        const deployments = _getDeployments();
        if (!deployments.chains[chainId]) {
            console.log(`ℹ️  No deployment found for chainId ${chainId}`);
            return;
        }
        delete deployments.chains[chainId];
        _modifiedDeployments = deployments;
        _writeDeploymentsFile(deploymentsPath, deployments);
        console.log(`✅ Removed localhost deployment for chainId ${chainId}`);
    }
    catch (error) {
        console.error(`❌ Failed to remove localhost deployment:`, error);
        throw error;
    }
}
/**
 * List all deployments including any localhost ones you've added
 */
function listAllDeployments() {
    const deployments = _getDeployments();
    return deployments.chains;
}
/**
 * Check if a localhost deployment exists
 */
function hasLocalhostDeployment(chainId = 31337) {
    const deployments = _getDeployments();
    return !!deployments.chains[chainId];
}
// Internal helper functions
function _getDeployments() {
    // Return cached version if we have modifications
    if (_modifiedDeployments) {
        return _modifiedDeployments;
    }
    // Otherwise load from the original file
    return require('../esp.deployments').espDeployments;
}
function _getDeploymentsFilePath() {
    // The compiled files will be in dist/cjs/src/ or dist/esm/src/
    // The esp.deployments.ts file is at the package root
    // So we need to go up from dist/cjs/src/ or dist/esm/src/ to reach the root
    // const relativePath = path.join(__dirname, '..', 'esp.deployments.ts');
    // if (fs.existsSync(relativePath)) {
    //   return relativePath;
    // }
    // all build files are js, ts is only in the package root, which won't change via this script
    const relativePathJs = path.join(__dirname, '..', 'esp.deployments.js');
    if (fs.existsSync(relativePathJs)) {
        return relativePathJs;
    }
    // // Fallback: try to find it by walking up the directory tree
    // let currentDir = __dirname;
    // for (let i = 0; i < 5; i++) { // Limit search depth
    //   const potentialPath = path.join(currentDir, 'esp.deployments.ts');
    //   if (fs.existsSync(potentialPath)) {
    //     return potentialPath;
    //   }
    //   currentDir = path.dirname(currentDir);
    // }
    throw new Error('Could not find esp.deployments.js file');
}
function _writeDeploymentsFile(filePath, deployments) {
    // Read the current file to preserve the structure
    const currentContent = fs.readFileSync(filePath, 'utf8');
    // Find the chains object and replace it
    const chainsStart = currentContent.indexOf('chains: {');
    const chainsEnd = _findMatchingBrace(currentContent, chainsStart + 'chains: '.length);
    if (chainsStart === -1 || chainsEnd === -1) {
        throw new Error('Could not parse esp.deployments.ts file structure');
    }
    // Generate the new chains content
    const chainsContent = JSON.stringify(deployments.chains, null, 4)
        .replace(/^{/, '')
        .replace(/}$/, '')
        .split('\n')
        .map((line, index) => index === 0 ? line : `  ${line}`)
        .join('\n');
    // Reconstruct the file
    const beforeChains = currentContent.substring(0, chainsStart + 'chains: {'.length);
    const afterChains = currentContent.substring(chainsEnd);
    const newContent = beforeChains + '\n' + chainsContent + '\n  ' + afterChains;
    fs.writeFileSync(filePath, newContent, 'utf8');
}
function _findMatchingBrace(content, startPos) {
    let braceCount = 1;
    let i = content.indexOf('{', startPos) + 1;
    while (i < content.length && braceCount > 0) {
        if (content[i] === '{')
            braceCount++;
        if (content[i] === '}')
            braceCount--;
        if (braceCount === 0)
            return i;
        i++;
    }
    return -1;
}
//# sourceMappingURL=deployments.js.map